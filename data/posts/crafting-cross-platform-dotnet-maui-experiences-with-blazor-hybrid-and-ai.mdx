---
title: 'Crafting Cross-Platform .NET MAUI Experiences with Blazor Hybrid & AI'
description: 'Learn how to build sophisticated cross-platform UIs with .NET MAUI and Blazor Hybrid, then integrate AI capabilities to create intelligent user experiences using a shared C# codebase.'
pubDate: 'May 10 2025'
image: 'https://ik.imagekit.io/quadrate/assets/img/dotnetevangelist/maui-blazor-ai.png?updatedAt=1746906590698'
category: '.NET'
tags: ['MAUI', 'Blazor Hybrid', 'AI', 'Cross-Platform', 'C#', '.NET', 'ML.NET', 'Mobile Development']
---

# Crafting Cross-Platform .NET MAUI Experiences with Blazor Hybrid & AI

In the rapidly evolving landscape of cross-platform development, .NET MAUI (Multi-platform App UI) has emerged as Microsoft's unified framework for building native mobile and desktop apps with C# and XAML. When combined with Blazor Hybrid and AI capabilities, it creates a powerful ecosystem for developing sophisticated, intelligent applications that run seamlessly across iOS, Android, macOS, and Windows.

This article explores how to leverage Blazor Hybrid within .NET MAUI applications and integrate AI features to create truly next-generation cross-platform experiences.

## Understanding .NET MAUI and Blazor Hybrid

### What is .NET MAUI?

.NET MAUI is Microsoft's evolution of Xamarin.Forms, providing a unified framework for building native mobile and desktop apps with a single codebase. MAUI allows developers to use C# and XAML to create applications that run natively on iOS, Android, macOS, and Windows.

### What is Blazor Hybrid?

Blazor Hybrid combines the best of both worlds:

- **Blazor**: A framework for building interactive web UIs using C# instead of JavaScript
- **Native Platforms**: The ability to run these web UIs within native applications

In a Blazor Hybrid app, Blazor components run on .NET in the native application process (not WebAssembly), while the UI is rendered to an embedded WebView control. This approach allows developers to:

1. Reuse web UI components in native applications
2. Access native platform features directly from C# code
3. Share business logic across web and native platforms
4. Leverage the rich Blazor component ecosystem

## Setting Up a .NET MAUI Blazor Hybrid Project

Let's start by creating a new .NET MAUI Blazor Hybrid application:

```bash
dotnet new maui-blazor -n MauiBlazorAI
```

This command creates a new .NET MAUI project with Blazor Hybrid integration. The project structure includes:

- **MauiProgram.cs**: The entry point for the application
- **wwwroot/**: Contains web assets like CSS, JavaScript, and images
- **Pages/**: Contains Blazor components
- **Platforms/**: Platform-specific code for iOS, Android, macOS, and Windows

### Understanding the Project Structure

The key components of a MAUI Blazor Hybrid application include:

1. **BlazorWebView**: A MAUI control that hosts Blazor content
2. **MauiApp**: The application host that configures services and initializes the app
3. **Shared Razor Components**: UI components that can be reused across platforms

Here's how the main page is structured in `MainPage.xaml`:

```xml
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:b="clr-namespace:Microsoft.AspNetCore.Components.WebView.Maui;assembly=Microsoft.AspNetCore.Components.WebView.Maui"
             xmlns:local="clr-namespace:MauiBlazorAI"
             x:Class="MauiBlazorAI.MainPage">

    <b:BlazorWebView HostPage="wwwroot/index.html">
        <b:BlazorWebView.RootComponents>
            <b:RootComponent Selector="#app" ComponentType="{x:Type local:Main}" />
        </b:BlazorWebView.RootComponents>
    </b:BlazorWebView>

</ContentPage>
```

## Building Rich UIs with Blazor Components in MAUI

One of the key advantages of using Blazor Hybrid in MAUI is the ability to leverage the rich ecosystem of Blazor components and libraries. Let's create a sophisticated UI using some popular Blazor component libraries.

### Adding Blazor Component Libraries

First, add a reference to a popular Blazor component library like MudBlazor:

```bash
dotnet add package MudBlazor
```

Then, configure the library in `MauiProgram.cs`:

```csharp
using MudBlazor.Services;

public static MauiApp CreateMauiApp()
{
    var builder = MauiApp.CreateBuilder();
    builder
        .UseMauiApp<App>()
        .ConfigureFonts(fonts =>
        {
            fonts.AddFont("OpenSans-Regular.ttf", "OpenSansRegular");
        });

    builder.Services.AddMauiBlazorWebView();
    
    // Add MudBlazor services
    builder.Services.AddMudServices();
    
    return builder.Build();
}
```

### Creating a Rich Dashboard UI

Now, let's create a dashboard page using MudBlazor components:

```razor
@page "/dashboard"
@using MudBlazor
@inject IJSRuntime JSRuntime

<MudContainer MaxWidth="MaxWidth.Large" Class="mt-4">
    <MudText Typo="Typo.h3" Class="mb-4">Smart Home Dashboard</MudText>
    
    <MudGrid>
        <MudItem xs="12" sm="6" md="3">
            <MudPaper Elevation="2" Class="pa-4" Style="height: 150px;">
                <MudText Typo="Typo.h5">Temperature</MudText>
                <MudText Typo="Typo.h3">72°F</MudText>
                <MudText Typo="Typo.body2">Living Room</MudText>
            </MudPaper>
        </MudItem>
        
        <MudItem xs="12" sm="6" md="3">
            <MudPaper Elevation="2" Class="pa-4" Style="height: 150px;">
                <MudText Typo="Typo.h5">Humidity</MudText>
                <MudText Typo="Typo.h3">45%</MudText>
                <MudText Typo="Typo.body2">Living Room</MudText>
            </MudPaper>
        </MudItem>
        
        <MudItem xs="12" sm="6" md="3">
            <MudPaper Elevation="2" Class="pa-4" Style="height: 150px;">
                <MudText Typo="Typo.h5">Lights</MudText>
                <MudSwitch @bind-Checked="lightsOn" Color="Color.Primary" />
                <MudText Typo="Typo.body2">Living Room</MudText>
            </MudPaper>
        </MudItem>
        
        <MudItem xs="12" sm="6" md="3">
            <MudPaper Elevation="2" Class="pa-4" Style="height: 150px;">
                <MudText Typo="Typo.h5">Security</MudText>
                <MudChip Color="Color.Success" Size="Size.Large">Armed</MudChip>
                <MudText Typo="Typo.body2">All Zones</MudText>
            </MudPaper>
        </MudItem>
    </MudGrid>
    
    <MudDivider Class="my-6" />
    
    <MudText Typo="Typo.h4" Class="mb-4">Recent Activity</MudText>
    <MudList>
        <MudListItem>
            <MudText>Front door opened at 8:30 AM</MudText>
        </MudListItem>
        <MudListItem>
            <MudText>Temperature adjusted to 72°F at 7:45 AM</MudText>
        </MudListItem>
        <MudListItem>
            <MudText>Lights turned off at 11:30 PM yesterday</MudText>
        </MudListItem>
    </MudList>
</MudContainer>

@code {
    private bool lightsOn = true;
}
```

## Bridging Native and Web: Accessing Native Features from Blazor

One of the powerful aspects of Blazor Hybrid in MAUI is the ability to access native platform features directly from your Blazor components. Let's explore how to implement this:

### Creating a Native Service

First, create a service that accesses native device features:

```csharp
// DeviceService.cs
public interface IDeviceService
{
    Task<string> GetDeviceInfo();
    Task<bool> TakePicture(string fileName);
    Task<GeoLocation> GetCurrentLocation();
}

public class DeviceService : IDeviceService
{
    public async Task<string> GetDeviceInfo()
    {
        return $"Device: {DeviceInfo.Model}, Platform: {DeviceInfo.Platform}, OS: {DeviceInfo.VersionString}";
    }
    
    public async Task<bool> TakePicture(string fileName)
    {
        if (!MediaPicker.IsCaptureSupported)
            return false;
            
        var photo = await MediaPicker.CapturePhotoAsync();
        if (photo == null)
            return false;
            
        var newFile = Path.Combine(FileSystem.CacheDirectory, fileName);
        using var stream = await photo.OpenReadAsync();
        using var newStream = File.OpenWrite(newFile);
        await stream.CopyToAsync(newStream);
        
        return true;
    }
    
    public async Task<GeoLocation> GetCurrentLocation()
    {
        try
        {
            var location = await Geolocation.GetLastKnownLocationAsync();
            if (location == null)
            {
                location = await Geolocation.GetLocationAsync(new GeolocationRequest
                {
                    DesiredAccuracy = GeolocationAccuracy.Medium,
                    Timeout = TimeSpan.FromSeconds(30)
                });
            }
            
            return new GeoLocation
            {
                Latitude = location.Latitude,
                Longitude = location.Longitude,
                Altitude = location.Altitude ?? 0
            };
        }
        catch
        {
            return null;
        }
    }
}

public class GeoLocation
{
    public double Latitude { get; set; }
    public double Longitude { get; set; }
    public double Altitude { get; set; }
}
```

### Registering the Service

Register the service in `MauiProgram.cs`:

```csharp
builder.Services.AddSingleton<IDeviceService, DeviceService>();
```

### Using Native Features in Blazor Components

Now, use the service in a Blazor component:

```razor
@page "/device-features"
@using MauiBlazorAI.Services
@inject IDeviceService DeviceService
@inject IJSRuntime JSRuntime

<MudContainer>
    <MudText Typo="Typo.h3" Class="mb-4">Device Features</MudText>
    
    <MudCard Class="mb-4">
        <MudCardContent>
            <MudText Typo="Typo.h5">Device Information</MudText>
            <MudText>@deviceInfo</MudText>
        </MudCardContent>
        <MudCardActions>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="GetDeviceInfoAsync">
                Get Device Info
            </MudButton>
        </MudCardActions>
    </MudCard>
    
    <MudCard Class="mb-4">
        <MudCardContent>
            <MudText Typo="Typo.h5">Camera</MudText>
            @if (!string.IsNullOrEmpty(photoPath))
            {
                <img src="@photoPath" style="max-width: 100%; max-height: 300px;" />
            }
        </MudCardContent>
        <MudCardActions>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="TakePictureAsync">
                Take Picture
            </MudButton>
        </MudCardActions>
    </MudCard>
    
    <MudCard>
        <MudCardContent>
            <MudText Typo="Typo.h5">Location</MudText>
            @if (location != null)
            {
                <MudText>Latitude: @location.Latitude</MudText>
                <MudText>Longitude: @location.Longitude</MudText>
                <MudText>Altitude: @location.Altitude m</MudText>
            }
        </MudCardContent>
        <MudCardActions>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="GetLocationAsync">
                Get Location
            </MudButton>
        </MudCardActions>
    </MudCard>
</MudContainer>

@code {
    private string deviceInfo;
    private string photoPath;
    private GeoLocation location;
    
    private async Task GetDeviceInfoAsync()
    {
        deviceInfo = await DeviceService.GetDeviceInfo();
    }
    
    private async Task TakePictureAsync()
    {
        var fileName = $"photo_{DateTime.Now.Ticks}.jpg";
        var success = await DeviceService.TakePicture(fileName);
        if (success)
        {
            photoPath = Path.Combine(FileSystem.CacheDirectory, fileName);
        }
    }
    
    private async Task GetLocationAsync()
    {
        location = await DeviceService.GetCurrentLocation();
    }
}
```

## Integrating AI Capabilities

Now, let's explore how to integrate AI capabilities into our .NET MAUI Blazor Hybrid application. We'll focus on two approaches:

1. On-device ML using ML.NET
2. Cloud-based AI using Azure Cognitive Services

### On-Device Sentiment Analysis with ML.NET

First, add the required packages:

```bash
dotnet add package Microsoft.ML
dotnet add package Microsoft.ML.FastTree
```

Create a sentiment analysis service:

```csharp
// SentimentAnalysisService.cs
public class SentimentAnalysisService
{
    private PredictionEngine<SentimentData, SentimentPrediction> _predictionEngine;
    
    public SentimentAnalysisService()
    {
        // Create ML context
        var mlContext = new MLContext();
        
        // Define the data schema
        var dataView = mlContext.Data.LoadFromEnumerable(new List<SentimentData>());
        
        // Define the pipeline
        var pipeline = mlContext.Transforms.Text.FeaturizeText("Features", nameof(SentimentData.Text))
            .Append(mlContext.BinaryClassification.Trainers.FastTree(numberOfLeaves: 50, numberOfTrees: 50));
        
        // Train the model (in a real app, you'd load a pre-trained model)
        var model = pipeline.Fit(dataView);
        
        // Create prediction engine
        _predictionEngine = mlContext.Model.CreatePredictionEngine<SentimentData, SentimentPrediction>(model);
    }
    
    public SentimentPrediction PredictSentiment(string text)
    {
        return _predictionEngine.Predict(new SentimentData { Text = text });
    }
}

public class SentimentData
{
    public string Text { get; set; }
    public bool Label { get; set; }
}

public class SentimentPrediction
{
    [ColumnName("PredictedLabel")]
    public bool Prediction { get; set; }
    
    public float Probability { get; set; }
    
    public float Score { get; set; }
}
```

Register the service:

```csharp
builder.Services.AddSingleton<SentimentAnalysisService>();
```

Create a sentiment analysis page:

```razor
@page "/sentiment-analysis"
@using MauiBlazorAI.Services
@inject SentimentAnalysisService SentimentService

<MudContainer>
    <MudText Typo="Typo.h3" Class="mb-4">Sentiment Analysis</MudText>
    
    <MudTextField @bind-Value="userInput" Label="Enter text to analyze" Variant="Variant.Outlined" 
                 Lines="3" Class="mb-4" />
    
    <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="AnalyzeSentiment" Class="mb-4">
        Analyze Sentiment
    </MudButton>
    
    @if (prediction != null)
    {
        <MudPaper Class="pa-4 mt-4" Elevation="3">
            <MudText Typo="Typo.h5">Analysis Results</MudText>
            <MudText>
                Sentiment: @(prediction.Prediction ? "Positive" : "Negative")
            </MudText>
            <MudText>
                Confidence: @(prediction.Probability.ToString("P2"))
            </MudText>
            
            <MudProgressLinear Color="@(prediction.Prediction ? Color.Success : Color.Error)" 
                              Value="@(prediction.Probability * 100)" Class="mt-2" />
        </MudPaper>
    }
</MudContainer>

@code {
    private string userInput = "";
    private SentimentPrediction prediction;
    
    private void AnalyzeSentiment()
    {
        if (!string.IsNullOrWhiteSpace(userInput))
        {
            prediction = SentimentService.PredictSentiment(userInput);
        }
    }
}
```

### Cloud-Based Image Analysis with Azure Cognitive Services

Add the required packages:

```bash
dotnet add package Microsoft.Azure.CognitiveServices.Vision.ComputerVision
```

Create an image analysis service:

```csharp
// ImageAnalysisService.cs
public class ImageAnalysisService
{
    private readonly ComputerVisionClient _client;
    
    public ImageAnalysisService(string subscriptionKey, string endpoint)
    {
        _client = new ComputerVisionClient(new ApiKeyServiceClientCredentials(subscriptionKey))
        {
            Endpoint = endpoint
        };
    }
    
    public async Task<ImageAnalysisResult> AnalyzeImageAsync(Stream imageStream)
    {
        var features = new List<VisualFeatureTypes?>()
        {
            VisualFeatureTypes.Categories,
            VisualFeatureTypes.Description,
            VisualFeatureTypes.Tags,
            VisualFeatureTypes.Objects,
            VisualFeatureTypes.Faces
        };
        
        var results = await _client.AnalyzeImageInStreamAsync(imageStream, features);
        
        return new ImageAnalysisResult
        {
            Description = results.Description.Captions.FirstOrDefault()?.Text ?? "No description available",
            Confidence = results.Description.Captions.FirstOrDefault()?.Confidence ?? 0,
            Tags = results.Tags.Select(t => t.Name).ToList(),
            Objects = results.Objects.Select(o => o.ObjectProperty).ToList()
        };
    }
}

public class ImageAnalysisResult
{
    public string Description { get; set; }
    public double Confidence { get; set; }
    public List<string> Tags { get; set; } = new List<string>();
    public List<string> Objects { get; set; } = new List<string>();
}
```

Register the service with appropriate configuration:

```csharp
builder.Services.AddSingleton<ImageAnalysisService>(sp => 
    new ImageAnalysisService(
        "your-subscription-key", 
        "your-endpoint"
    )
);
```

Create an image analysis page:

```razor
@page "/image-analysis"
@using MauiBlazorAI.Services
@inject ImageAnalysisService ImageService
@inject IDeviceService DeviceService

<MudContainer>
    <MudText Typo="Typo.h3" Class="mb-4">Image Analysis</MudText>
    
    <MudCard Class="mb-4">
        <MudCardContent>
            @if (!string.IsNullOrEmpty(imagePath))
            {
                <img src="@imagePath" style="max-width: 100%; max-height: 300px;" />
            }
            else
            {
                <MudText>Take a picture to analyze it</MudText>
            }
        </MudCardContent>
        <MudCardActions>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="TakePictureAsync">
                Take Picture
            </MudButton>
            <MudButton Variant="Variant.Filled" Color="Color.Secondary" OnClick="AnalyzeImageAsync"
                      Disabled="@(string.IsNullOrEmpty(imagePath))">
                Analyze Image
            </MudButton>
        </MudCardActions>
    </MudCard>
    
    @if (analysisResult != null)
    {
        <MudPaper Class="pa-4" Elevation="3">
            <MudText Typo="Typo.h5">Analysis Results</MudText>
            <MudText Typo="Typo.body1">Description: @analysisResult.Description</MudText>
            <MudText Typo="Typo.body1">Confidence: @(analysisResult.Confidence.ToString("P2"))</MudText>
            
            <MudText Typo="Typo.h6" Class="mt-2">Tags:</MudText>
            <MudChipSet>
                @foreach (var tag in analysisResult.Tags)
                {
                    <MudChip Color="Color.Primary">@tag</MudChip>
                }
            </MudChipSet>
            
            <MudText Typo="Typo.h6" Class="mt-2">Objects:</MudText>
            <MudChipSet>
                @foreach (var obj in analysisResult.Objects)
                {
                    <MudChip Color="Color.Secondary">@obj</MudChip>
                }
            </MudChipSet>
        </MudPaper>
    }
</MudContainer>

@code {
    private string imagePath;
    private ImageAnalysisResult analysisResult;
    
    private async Task TakePictureAsync()
    {
        var fileName = $"analysis_{DateTime.Now.Ticks}.jpg";
        var success = await DeviceService.TakePicture(fileName);
        if (success)
        {
            imagePath = Path.Combine(FileSystem.CacheDirectory, fileName);
        }
    }
    
    private async Task AnalyzeImageAsync()
    {
        if (string.IsNullOrEmpty(imagePath))
            return;
            
        using var stream = File.OpenRead(imagePath);
        analysisResult = await ImageService.AnalyzeImageAsync(stream);
    }
}
```

## Performance Optimization and Best Practices

To ensure your .NET MAUI Blazor Hybrid application runs smoothly across all platforms, consider these performance optimization techniques:

### 1. Minimize JavaScript Interop

While JavaScript interop is available, excessive use can impact performance. Keep JS interop calls to a minimum and batch them when possible.

### 2. Use Virtualization for Large Lists

When displaying large lists, use Blazor's built-in virtualization to render only the visible items:

```razor
<MudList Style="height: 400px; overflow-y: scroll">
    <Virtualize Items="@largeDataSet" Context="item">
        <MudListItem>
            <MudText>@item.Name</MudText>
        </MudListItem>
    </Virtualize>
</MudList>
```

### 3. Implement Lazy Loading

Load components and data only when needed:

```csharp
@if (isComponentVisible)
{
    <ExpensiveComponent />
}
```

### 4. Use State Management Effectively

Implement proper state management to avoid unnecessary re-renders:

```csharp
// AppState.cs
public class AppState
{
    private readonly List<Action> _listeners = new();
    
    public UserProfile CurrentUser { get; private set; }
    
    public void SetUser(UserProfile user)
    {
        CurrentUser = user;
        NotifyStateChanged();
    }
    
    public event Action OnChange
    {
        add
        {
            _listeners.Add(value);
        }
        remove
        {
            _listeners.Remove(value);
        }
    }
    
    private void NotifyStateChanged() => _listeners.ForEach(listener => listener());
}

// Register in MauiProgram.cs
builder.Services.AddSingleton<AppState>();
```

### 5. Optimize WebView Performance

Configure the WebView for optimal performance:

```xml
<BlazorWebView HostPage="wwwroot/index.html">
    <BlazorWebView.RootComponents>
        <RootComponent Selector="#app" ComponentType="{x:Type local:Main}" />
    </BlazorWebView.RootComponents>
    <BlazorWebView.WebViewSettings>
        <WebViewSettings EnableJavaScriptInterface="true" />
    </BlazorWebView.WebViewSettings>
</BlazorWebView>
```

## Conclusion

.NET MAUI with Blazor Hybrid and AI capabilities represents a powerful combination for building sophisticated cross-platform applications. By leveraging Blazor's component model within native applications and integrating AI features, developers can create intelligent, responsive experiences that work seamlessly across multiple platforms.

The ability to write once and deploy everywhere, while still accessing native platform features and implementing advanced AI capabilities, makes this stack particularly compelling for modern application development. As the ecosystem continues to evolve, we can expect even more powerful tools and libraries to emerge, further enhancing the developer experience and enabling even more sophisticated applications.

Whether you're building consumer apps, enterprise solutions, or specialized tools, the combination of .NET MAUI, Blazor Hybrid, and AI provides a comprehensive toolkit for creating next-generation cross-platform experiences.
