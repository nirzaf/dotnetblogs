---
title: Implementing JWT Authentication in Blazor WebAssembly
date: '2023-10-18'
description: 'Learn how to implement secure JWT authentication in Blazor WebAssembly applications with role-based authorization and token refresh.'
image: 'https://ik.imagekit.io/quadrate/assets/img/dotnetevangelist/blazor_web_assembly_jwt.jpg?updatedAt=1746813307225'
tags: ['blazor', 'webassembly', 'authentication', 'jwt', 'dotnet']
---

# Implementing JWT Authentication in Blazor WebAssembly

Blazor WebAssembly allows developers to build interactive web applications using C# instead of JavaScript. When building real-world applications, implementing secure authentication is crucial. In this post, we'll explore how to implement JWT (JSON Web Token) authentication in a Blazor WebAssembly application.

## Understanding JWT Authentication in Blazor

JWT authentication in Blazor WebAssembly involves:

1. Sending credentials to an authentication endpoint
2. Receiving and storing JWT tokens
3. Attaching tokens to outgoing requests
4. Handling token expiration and refresh
5. Implementing authorization based on claims

Let's dive into each of these steps.

## Setting Up the Authentication Service

First, let's create an authentication service that will handle the JWT operations:

```csharp
using System.Net.Http.Headers;
using System.Net.Http.Json;
using System.Security.Claims;
using System.Text.Json;
using Blazored.LocalStorage;
using Microsoft.AspNetCore.Components.Authorization;

public class AuthService : IAuthService
{
    private readonly HttpClient _httpClient;
    private readonly AuthenticationStateProvider _authStateProvider;
    private readonly ILocalStorageService _localStorage;

    public AuthService(
        HttpClient httpClient,
        AuthenticationStateProvider authStateProvider,
        ILocalStorageService localStorage)
    {
        _httpClient = httpClient;
        _authStateProvider = authStateProvider;
        _localStorage = localStorage;
    }

    public async Task<LoginResult> Login(LoginModel loginModel)
    {
        var response = await _httpClient.PostAsJsonAsync("api/auth/login", loginModel);
        var content = await response.Content.ReadFromJsonAsync<LoginResult>();

        if (!response.IsSuccessStatusCode)
        {
            return content;
        }

        await _localStorage.SetItemAsync("authToken", content.Token);
        await _localStorage.SetItemAsync("refreshToken", content.RefreshToken);
        
        ((ApiAuthenticationStateProvider)_authStateProvider).MarkUserAsAuthenticated(content.Token);
        _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("bearer", content.Token);

        return content;
    }

    public async Task Logout()
    {
        await _localStorage.RemoveItemAsync("authToken");
        await _localStorage.RemoveItemAsync("refreshToken");
        
        ((ApiAuthenticationStateProvider)_authStateProvider).MarkUserAsLoggedOut();
        _httpClient.DefaultRequestHeaders.Authorization = null;
    }

    public async Task<string> RefreshToken()
    {
        var token = await _localStorage.GetItemAsync<string>("authToken");
        var refreshToken = await _localStorage.GetItemAsync<string>("refreshToken");

        var response = await _httpClient.PostAsJsonAsync("api/auth/refresh", new RefreshTokenModel
        {
            Token = token,
            RefreshToken = refreshToken
        });

        var content = await response.Content.ReadFromJsonAsync<LoginResult>();

        if (!response.IsSuccessStatusCode)
        {
            await Logout();
            return null;
        }

        await _localStorage.SetItemAsync("authToken", content.Token);
        await _localStorage.SetItemAsync("refreshToken", content.RefreshToken);
        
        _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("bearer", content.Token);
        
        return content.Token;
    }
}
```

## Custom Authentication State Provider

Next, we need a custom `AuthenticationStateProvider` to manage the authentication state:

```csharp
using System.Net.Http.Headers;
using System.Security.Claims;
using System.Text.Json;
using Blazored.LocalStorage;
using Microsoft.AspNetCore.Components.Authorization;

public class ApiAuthenticationStateProvider : AuthenticationStateProvider
{
    private readonly HttpClient _httpClient;
    private readonly ILocalStorageService _localStorage;

    public ApiAuthenticationStateProvider(
        HttpClient httpClient,
        ILocalStorageService localStorage)
    {
        _httpClient = httpClient;
        _localStorage = localStorage;
    }

    public override async Task<AuthenticationState> GetAuthenticationStateAsync()
    {
        var savedToken = await _localStorage.GetItemAsync<string>("authToken");
        
        if (string.IsNullOrWhiteSpace(savedToken))
        {
            return new AuthenticationState(new ClaimsPrincipal(new ClaimsIdentity()));
        }

        _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("bearer", savedToken);
        
        return new AuthenticationState(new ClaimsPrincipal(
            new ClaimsIdentity(ParseClaimsFromJwt(savedToken), "jwt")));
    }

    public void MarkUserAsAuthenticated(string token)
    {
        var authenticatedUser = new ClaimsPrincipal(
            new ClaimsIdentity(ParseClaimsFromJwt(token), "jwt"));
        
        var authState = Task.FromResult(new AuthenticationState(authenticatedUser));
        NotifyAuthenticationStateChanged(authState);
    }

    public void MarkUserAsLoggedOut()
    {
        var anonymousUser = new ClaimsPrincipal(new ClaimsIdentity());
        var authState = Task.FromResult(new AuthenticationState(anonymousUser));
        NotifyAuthenticationStateChanged(authState);
    }

    private IEnumerable<Claim> ParseClaimsFromJwt(string jwt)
    {
        var claims = new List<Claim>();
        var payload = jwt.Split('.')[1];
        var jsonBytes = ParseBase64WithoutPadding(payload);
        var keyValuePairs = JsonSerializer.Deserialize<Dictionary<string, object>>(jsonBytes);

        keyValuePairs.TryGetValue(ClaimTypes.Role, out object roles);

        if (roles != null)
        {
            if (roles.ToString().Trim().StartsWith("["))
            {
                var parsedRoles = JsonSerializer.Deserialize<string[]>(roles.ToString());

                foreach (var parsedRole in parsedRoles)
                {
                    claims.Add(new Claim(ClaimTypes.Role, parsedRole));
                }
            }
            else
            {
                claims.Add(new Claim(ClaimTypes.Role, roles.ToString()));
            }

            keyValuePairs.Remove(ClaimTypes.Role);
        }

        claims.AddRange(keyValuePairs.Select(kvp => new Claim(kvp.Key, kvp.Value.ToString())));

        return claims;
    }

    private byte[] ParseBase64WithoutPadding(string base64)
    {
        switch (base64.Length % 4)
        {
            case 2: base64 += "=="; break;
            case 3: base64 += "="; break;
        }
        return Convert.FromBase64String(base64);
    }
}
```

## HTTP Client Handler for Token Refresh

To handle token expiration, we'll create a custom `DelegatingHandler` that automatically refreshes the token when needed:

```csharp
public class AuthorizationMessageHandler : DelegatingHandler
{
    private readonly IAuthService _authService;
    private readonly NavigationManager _navigationManager;

    public AuthorizationMessageHandler(
        IAuthService authService,
        NavigationManager navigationManager)
    {
        _authService = authService;
        _navigationManager = navigationManager;
    }

    protected override async Task<HttpResponseMessage> SendAsync(
        HttpRequestMessage request, CancellationToken cancellationToken)
    {
        var response = await base.SendAsync(request, cancellationToken);

        if (response.StatusCode == System.Net.HttpStatusCode.Unauthorized)
        {
            // Try to refresh the token
            var token = await _authService.RefreshToken();
            
            if (string.IsNullOrEmpty(token))
            {
                // If refresh fails, redirect to login
                _navigationManager.NavigateTo("/login");
                return response;
            }

            // Retry the request with the new token
            request.Headers.Authorization = new AuthenticationHeaderValue("bearer", token);
            response = await base.SendAsync(request, cancellationToken);
        }

        return response;
    }
}
```

## Registering Services in Program.cs

Now, let's register all these services in the `Program.cs` file:

```csharp
using Blazored.LocalStorage;
using Microsoft.AspNetCore.Components.Authorization;
using Microsoft.AspNetCore.Components.Web;
using Microsoft.AspNetCore.Components.WebAssembly.Hosting;

var builder = WebAssemblyHostBuilder.CreateDefault(args);
builder.RootComponents.Add<App>("#app");
builder.RootComponents.Add<HeadOutlet>("head::after");

// Add Blazored LocalStorage
builder.Services.AddBlazoredLocalStorage();

// Add Authentication services
builder.Services.AddScoped<AuthenticationStateProvider, ApiAuthenticationStateProvider>();
builder.Services.AddScoped<IAuthService, AuthService>();

// Add HTTP client with auth handler
builder.Services.AddScoped<AuthorizationMessageHandler>();
builder.Services.AddHttpClient("API", client => 
{
    client.BaseAddress = new Uri(builder.Configuration["ApiUrl"]);
})
.AddHttpMessageHandler<AuthorizationMessageHandler>();

builder.Services.AddScoped(sp => sp.GetRequiredService<IHttpClientFactory>()
    .CreateClient("API"));

// Add auth state provider
builder.Services.AddAuthorizationCore();

await builder.Build().RunAsync();
```

## Creating the Login Component

Let's create a login component to handle user authentication:

```razor
@page "/login"
@inject IAuthService AuthService
@inject NavigationManager NavigationManager

<h3>Login</h3>

@if (!string.IsNullOrEmpty(error))
{
    <div class="alert alert-danger">
        @error
    </div>
}

<div class="card">
    <div class="card-body">
        <EditForm Model="@loginModel" OnValidSubmit="HandleLogin">
            <DataAnnotationsValidator />
            <ValidationSummary />

            <div class="form-group">
                <label for="email">Email</label>
                <InputText id="email" class="form-control" @bind-Value="loginModel.Email" />
                <ValidationMessage For="@(() => loginModel.Email)" />
            </div>

            <div class="form-group">
                <label for="password">Password</label>
                <InputText id="password" type="password" class="form-control" @bind-Value="loginModel.Password" />
                <ValidationMessage For="@(() => loginModel.Password)" />
            </div>

            <button type="submit" class="btn btn-primary" disabled="@isLoading">
                @if (isLoading)
                {
                    <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                    <span>Loading...</span>
                }
                else
                {
                    <span>Login</span>
                }
            </button>
        </EditForm>
    </div>
</div>

@code {
    private LoginModel loginModel = new LoginModel();
    private bool isLoading = false;
    private string error;

    private async Task HandleLogin()
    {
        isLoading = true;
        error = null;

        try
        {
            var result = await AuthService.Login(loginModel);
            
            if (result.Successful)
            {
                NavigationManager.NavigateTo("/");
            }
            else
            {
                error = result.Error;
            }
        }
        catch (Exception ex)
        {
            error = "An error occurred while logging in.";
            Console.WriteLine(ex.Message);
        }
        finally
        {
            isLoading = false;
        }
    }
}
```

## Implementing Authorization in Components

Now we can use the built-in authorization features in our components:

```razor
@page "/protected-page"
@attribute [Authorize]

<h3>Protected Page</h3>

<p>This page can only be accessed by authenticated users.</p>

@code {
    // Component logic
}
```

For role-based authorization:

```razor
@page "/admin-page"
@attribute [Authorize(Roles = "Admin")]

<h3>Admin Page</h3>

<p>This page can only be accessed by users with the Admin role.</p>

@code {
    // Component logic
}
```

## Adding a Logout Button

Finally, let's add a logout button to our navigation menu:

```razor
<AuthorizeView>
    <Authorized>
        <li class="nav-item">
            <a class="nav-link" href="#" @onclick="LogoutClick" @onclick:preventDefault>
                Logout
            </a>
        </li>
    </Authorized>
    <NotAuthorized>
        <li class="nav-item">
            <NavLink class="nav-link" href="login">
                Login
            </NavLink>
        </li>
    </NotAuthorized>
</AuthorizeView>

@code {
    @inject IAuthService AuthService
    @inject NavigationManager NavigationManager

    private async Task LogoutClick()
    {
        await AuthService.Logout();
        NavigationManager.NavigateTo("/");
    }
}
```

## Conclusion

Implementing JWT authentication in Blazor WebAssembly provides a secure way to protect your application's resources. By following the steps outlined in this post, you can create a robust authentication system that includes:

- Secure token storage using local storage
- Automatic token refresh
- Role-based authorization
- Clean separation of concerns

This approach ensures that your Blazor WebAssembly application is both secure and user-friendly, providing a seamless authentication experience for your users.

Happy coding!
